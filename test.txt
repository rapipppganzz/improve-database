--[[
    ðŸ”ï¸ AUTO MOUNTAIN CLIMBER BOT
    Fitur: Auto detect path, no manual checkpoint needed!
]]

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local PathfindingService = game:GetService("PathfindingService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local rootPart = character:WaitForChild("HumanoidRootPart")

-- Config
_G.Config = _G.Config or {
    Enabled = false,
    WalkSpeed = 25,
    AutoJump = true,
    SearchRadius = 100,
    SearchHeight = 200,
    TargetPosition = nil
}

-- ========== AUTO TARGET FINDER ==========
local function findHighestPoint()
    print("ðŸ” Mencari titik tertinggi di area...")
    
    local bestPosition = nil
    local highestY = -math.huge
    
    -- Scan area sekitar untuk mencari titik tinggi
    local scanRadius = _G.Config.SearchRadius
    local center = rootPart.Position
    
    for x = -scanRadius, scanRadius, 20 do
        for z = -scanRadius, scanRadius, 20 do
            local scanPos = Vector3.new(center.X + x, center.Y + _G.Config.SearchHeight, center.Z + z)
            
            -- Raycast ke bawah untuk cari permukaan
            local ray = Ray.new(scanPos, Vector3.new(0, -_G.Config.SearchHeight * 2, 0))
            local hit, position = workspace:FindPartOnRayWithIgnoreList(ray, {character})
            
            if hit and position.Y > highestY then
                highestY = position.Y
                bestPosition = position
            end
        end
    end
    
    if bestPosition then
        print("ðŸŽ¯ Titik tertinggi ditemukan: " .. tostring(bestPosition))
    else
        -- Fallback: cari part dengan nama finish/end/goal
        local finishParts = {
            "Finish", "End", "Goal", "Win", "Complete",
            "EndPoint", "FinishLine", "Victory"
        }
        
        for _, partName in ipairs(finishParts) do
            local part = workspace:FindFirstChild(partName)
            if part then
                bestPosition = part.Position
                print("ðŸŽ¯ Finish part ditemukan: " .. partName)
                break
            end
        end
    end
    
    return bestPosition
end

local function findPathToTarget()
    if not _G.Config.TargetPosition then
        _G.Config.TargetPosition = findHighestPoint()
        
        if not _G.Config.TargetPosition then
            -- Jika masih ga ketemu, coba explore random
            local randomPos = rootPart.Position + Vector3.new(
                math.random(-50, 50),
                math.random(10, 30),
                math.random(-50, 50)
            )
            _G.Config.TargetPosition = randomPos
            print("ðŸ” Explore random position")
        end
    end
    
    return _G.Config.TargetPosition
end

-- ========== SMART NAVIGATION ==========
local path = nil
local waypoints = nil
local currentWaypointIndex = 0
local lastStuckCheck = os.time()
local lastPosition = rootPart.Position

local function computePath(targetPosition)
    if not PathfindingService then 
        -- Simple direct movement jika pathfinding tidak tersedia
        return {{Position = targetPosition, Action = Enum.PathWaypointAction.Walk}}
    end
    
    local success, result = pcall(function()
        path = PathfindingService:CreatePath({
            AgentRadius = 2,
            AgentHeight = 5,
            AgentCanJump = true,
            WaypointSpacing = 6
        })
        
        path:ComputeAsync(rootPart.Position, targetPosition)
        
        if path.Status == Enum.PathStatus.Success then
            return path:GetWaypoints()
        else
            print("âš ï¸ Pathfinding gagal, menggunakan direct movement")
            return {{Position = targetPosition, Action = Enum.PathWaypointAction.Walk}}
        end
    end)
    
    return success and result or {{Position = targetPosition, Action = Enum.PathWaypointAction.Walk}}
end

local function moveToWaypoint()
    if not waypoints or currentWaypointIndex > #waypoints then
        return false
    end
    
    local waypoint = waypoints[currentWaypointIndex]
    local direction = (waypoint.Position - rootPart.Position).Unit
    
    -- Movement dengan obstacle avoidance
    humanoid:Move(direction)
    
    -- Cek jika sudah dekat waypoint
    local distance = (rootPart.Position - waypoint.Position).Magnitude
    if distance < 5 then
        currentWaypointIndex = currentWaypointIndex + 1
    end
    
    -- Handle jump waypoints
    if waypoint.Action == Enum.PathWaypointAction.Jump then
        humanoid.Jump = true
    end
    
    return currentWaypointIndex <= #waypoints
end

-- ========== OBSTACLE DETECTION ==========
local function checkFrontObstacle()
    local rayOrigin = rootPart.Position + Vector3.new(0, 2, 0)
    local rayDirection = rootPart.CFrame.LookVector * 8
    local ray = Ray.new(rayOrigin, rayDirection)
    
    local hit, position = workspace:FindPartOnRayWithIgnoreList(ray, {character})
    return hit and hit.CanCollide
end

local function checkClimbable()
    -- Deteksi jika ada tembok/tangga yang bisa dipanjat
    local rayOrigin = rootPart.Position + Vector3.new(0, 2, 0)
    local rayDirection = rootPart.CFrame.LookVector * 4
    local ray = Ray.new(rayOrigin, rayDirection)
    
    local hit, position = workspace:FindPartOnRayWithIgnoreList(ray, {character})
    if hit and hit.CanCollide then
        -- Cek jika objek tinggi (mungkin tembok/tangga)
        local topRay = Ray.new(position + Vector3.new(0, 10, 0), rayDirection)
        local topHit = workspace:FindPartOnRayWithIgnoreList(topRay, {character})
        return not topHit -- Jika tidak ada halangan di atas, berarti bisa dipanjat
    end
    
    return false
end

-- ========== ANTI-STUCK SYSTEM ==========
local function checkIfStuck()
    local currentTime = os.time()
    if currentTime - lastStuckCheck < 2 then return false end
    
    local currentPos = rootPart.Position
    local distanceMoved = (currentPos - lastPosition).Magnitude
    
    if distanceMoved < 2 then -- Hanya bergerak 2 studs dalam 2 detik
        print("ðŸ”„ Karakter stuck, mencari path baru...")
        lastStuckCheck = currentTime
        return true
    end
    
    lastPosition = currentPos
    lastStuckCheck = currentTime
    return false
end

-- ========== MAIN BOT BRAIN ==========
local function smartNavigation()
    if not _G.Config.Enabled then return end
    
    -- Update character references
    if not character or not character.Parent then
        character = player.Character
        if character then
            humanoid = character:FindFirstChildOfClass("Humanoid")
            rootPart = character:FindFirstChild("HumanoidRootPart")
        end
        return
    end
    
    if not humanoid or not rootPart then return end
    
    -- Set walk speed
    humanoid.WalkSpeed = _G.Config.WalkSpeed
    
    -- Anti-stuck system
    if checkIfStuck() then
        waypoints = nil
        _G.Config.TargetPosition = nil
        humanoid.Jump = true
        task.wait(0.5)
    end
    
    -- Cari target jika belum ada
    if not _G.Config.TargetPosition then
        findPathToTarget()
    end
    
    -- Compute path jika needed
    if not waypoints or currentWaypointIndex > #waypoints then
        local target = findPathToTarget()
        waypoints = computePath(target)
        currentWaypointIndex = 1
        print("ðŸ”„ Computing path ke target...")
    end
    
    -- Eksekusi movement
    if waypoints and currentWaypointIndex <= #waypoints then
        if not moveToWaypoint() then
            -- Path selesai, cari target baru
            print("âœ… Path selesai, mencari target baru...")
            waypoints = nil
            _G.Config.TargetPosition = nil
        end
    end
    
    -- Smart obstacle handling
    if _G.Config.AutoJump then
        if checkFrontObstacle() then
            humanoid.Jump = true
            task.wait(0.2)
        elseif checkClimbable() then
            -- Coba panjat dengan lompat berulang
            humanoid.Jump = true
            task.wait(0.3)
        end
    end
    
    -- Auto re-target setiap 30 detik
    if os.time() % 30 < 0.1 then
        _G.Config.TargetPosition = nil
        print("ðŸ”„ Auto re-targeting...")
    end
end

-- ========== SIMPLE MOBILE GUI ==========
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "MountainClimber"
ScreenGui.ResetOnSpawn = false

if gethui then
    ScreenGui.Parent = gethui()
else
    ScreenGui.Parent = game:GetService("CoreGui")
end

local Main = Instance.new("Frame")
Main.Parent = ScreenGui
Main.Size = UDim2.new(0, 280, 0, 200)
Main.Position = UDim2.new(0.02, 0, 0.4, 0)
Main.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
Main.BorderSizePixel = 2
Main.BorderColor3 = Color3.fromRGB(0, 200, 255)
Main.Active = true
Main.Draggable = true

local Title = Instance.new("TextLabel")
Title.Parent = Main
Title.Text = "ðŸ”ï¸ MOUNTAIN CLIMBER"
Title.Size = UDim2.new(1, 0, 0, 35)
Title.BackgroundColor3 = Color3.fromRGB(0, 100, 200)
Title.TextColor3 = Color3.white
Title.Font = Enum.Font.GothamBold

-- Start/Stop Button
local toggleBtn = Instance.new("TextButton")
toggleBtn.Parent = Main
toggleBtn.Size = UDim2.new(0.9, 0, 0, 40)
toggleBtn.Position = UDim2.new(0.05, 0, 0.2, 0)
toggleBtn.Text = "ðŸš€ START CLIMBING"
toggleBtn.BackgroundColor3 = Color3.fromRGB(0, 150, 0)
toggleBtn.TextColor3 = Color3.white
toggleBtn.Font = Enum.Font.Gotham
toggleBtn.TextSize = 14

toggleBtn.MouseButton1Click:Connect(function()
    _G.Config.Enabled = not _G.Config.Enabled
    
    if _G.Config.Enabled then
        toggleBtn.Text = "ðŸ›‘ STOP CLIMBING"
        toggleBtn.BackgroundColor3 = Color3.fromRGB(200, 0, 0)
        _G.Config.TargetPosition = nil -- Reset target
        waypoints = nil
        print("ðŸ”ï¸ Mountain Climber: STARTED")
    else
        toggleBtn.Text = "ðŸš€ START CLIMBING"
        toggleBtn.BackgroundColor3 = Color3.fromRGB(0, 150, 0)
        humanoid:Move(Vector3.new(0, 0, 0))
        print("ðŸ”ï¸ Mountain Climber: STOPPED")
    end
end)

-- Speed Control
local speedUp = Instance.new("TextButton")
speedUp.Parent = Main
speedUp.Size = UDim2.new(0.4, 0, 0, 30)
speedUp.Position = UDim2.new(0.52, 0, 0.5, 0)
speedUp.Text = "âž• SPEED"
speedUp.BackgroundColor3 = Color3.fromRGB(0, 100, 200)
speedUp.TextColor3 = Color3.white

local speedDown = Instance.new("TextButton")
speedDown.Parent = Main
speedDown.Size = UDim2.new(0.4, 0, 0, 30)
speedDown.Position = UDim2.new(0.05, 0, 0.5, 0)
speedDown.Text = "âž– SPEED"
speedDown.BackgroundColor3 = Color3.fromRGB(200, 100, 0)
speedDown.TextColor3 = Color3.white

local speedLbl = Instance.new("TextLabel")
speedLbl.Parent = Main
speedLbl.Size = UDim2.new(0.9, 0, 0, 20)
speedLbl.Position = UDim2.new(0.05, 0, 0.65, 0)
speedLbl.BackgroundTransparency = 1
speedLbl.Text = "âš¡ Speed: " .. _G.Config.WalkSpeed
speedLbl.TextColor3 = Color3.fromRGB(255, 255, 0)
speedLbl.Font = Enum.Font.Gotham

speedUp.MouseButton1Click:Connect(function()
    _G.Config.WalkSpeed = math.min(50, _G.Config.WalkSpeed + 5)
    speedLbl.Text = "âš¡ Speed: " .. _G.Config.WalkSpeed
end)

speedDown.MouseButton1Click:Connect(function()
    _G.Config.WalkSpeed = math.max(16, _G.Config.WalkSpeed - 5)
    speedLbl.Text = "âš¡ Speed: " .. _G.Config.WalkSpeed
end)

-- Status Display
local statusLbl = Instance.new("TextLabel")
statusLbl.Parent = Main
statusLbl.Size = UDim2.new(0.9, 0, 0, 60)
statusLbl.Position = UDim2.new(0.05, 0, 0.75, 0)
statusLbl.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
statusLbl.TextColor3 = Color3.fromRGB(0, 255, 150)
statusLbl.Font = Enum.Font.Gotham
statusLbl.TextSize = 11
statusLbl.TextWrapped = true
statusLbl.Text = "ðŸ¤– Status: Ready\nðŸ“ Tekan START untuk mulai!"

-- Close Button
local closeBtn = Instance.new("TextButton")
closeBtn.Parent = Main
closeBtn.Size = UDim2.new(0, 25, 0, 25)
closeBtn.Position = UDim2.new(0.9, 0, 0.02, 0)
closeBtn.Text = "X"
closeBtn.BackgroundColor3 = Color3.fromRGB(200, 0, 0)
closeBtn.TextColor3 = Color3.white

closeBtn.MouseButton1Click:Connect(function()
    _G.Config.Enabled = false
    ScreenGui:Destroy()
end)

-- ========== MAIN LOOP ==========
RunService.Heartbeat:Connect(function()
    if _G.Config.Enabled then
        local success, err = pcall(smartNavigation)
        if not success then
            print("âŒ Navigation error: " .. err)
            statusLbl.Text = "âŒ Error: " .. err
        end
        
        -- Update status
        if _G.Config.TargetPosition then
            local dist = math.floor((rootPart.Position - _G.Config.TargetPosition).Magnitude)
            local height = math.floor(rootPart.Position.Y)
            statusLbl.Text = "ðŸ”ï¸ Mendaki Gunung...\nðŸ“ Jarak target: " .. dist .. " studs\nðŸ“ Ketinggian: " .. height .. "m"
        else
            statusLbl.Text = "ðŸ” Mencari jalur pendakian..."
        end
    else
        statusLbl.Text = "ðŸ¤– Status: Ready\nðŸ“ Tekan START untuk mulai!"
    end
end)

-- ========== RESPAWN HANDLER ==========
player.CharacterAdded:Connect(function(newChar)
    character = newChar
    task.wait(1)
    humanoid = character:WaitForChild("Humanoid")
    rootPart = character:WaitForChild("HumanoidRootPart")
    
    -- Reset navigation
    waypoints = nil
    currentWaypointIndex = 0
    _G.Config.TargetPosition = nil
    
    print("ðŸ”ï¸ Character respawned - Climber reset")
end)

print("========================================")
print("ðŸ”ï¸ AUTO MOUNTAIN CLIMBER LOADED")
print("âœ… Auto Target Detection")
print("âœ… No Manual Checkpoint Needed") 
print("âœ… Smart Obstacle Climbing")
print("========================================")